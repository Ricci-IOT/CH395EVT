/********************************** (C) COPYRIGHT *********************************
 * File Name          : HTTPS.C
 * Author             : WCH
 * Version            : V2.0
 * Date               : 2025/04/02
 * Description        : Web interface functions
 *
 **********************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "https.h"
#include "ch395.h"
#include "ch395cmd.h"
#include "debug.h"

volatile UINT8 WebServer_flag = 0;
volatile UINT16 WebServer_len = 0;
UINT8 WebServer_RecvBuffer[4096];
volatile UINT16 WebServer_SendLen = 0;
volatile UINT8 *WebServer_Send_point = NULL;

/* Temporary variables and external variable declarations */
UINT8 ip[4], i, lastip[4], ADC[3];
UINT16 port, lastport;
char tempURI[MAX_URI_SIZE];
extern char homepage_default[], test[];
extern UINT8 HtmlBuffer[2716];
extern st_http_request *http_request;
char *ptr1, *name;
volatile char *ptemp;
extern UINT8 CH395IPAddr[4];
extern UINT16 Socket0SourPort;
UINT8 WebServer_handle_step = WEB_SERVER_STEP_IDLE;

/********************* WEB Response Message *********************************/
UINT8 httpweb[200];
/******************** HTML Text Information ********************************/
/* Can also be directly used, HTML formatted source file */
UINT8 HtmlBuffer[2716] = {
    0x3C, 0x21, 0x44, 0x4F, 0x43, 0x54, 0x59, 0x50, 0x45, 0x20, 0x68, 0x74, 0x6D, 0x6C, 0x3E, 0x0D,
    0x0A, 0x3C, 0x68, 0x74, 0x6D, 0x6C, 0x3E, 0x0D, 0x0A, 0x3C, 0x68, 0x65, 0x61, 0x64, 0x3E, 0x0D,
    0x0A, 0x3C, 0x62, 0x6F, 0x64, 0x79, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C, 0x2F, 0x68, 0x65, 0x61,
    0x64, 0x3E, 0x0D, 0x0A, 0x3C, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x64, 0x74, 0x68,
    0x3D, 0x22, 0x31, 0x32, 0x30, 0x30, 0x22, 0x20, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3D, 0x22,
    0x30, 0x22, 0x3E, 0x0D, 0x0A, 0x3C, 0x74, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x74, 0x64, 0x20, 0x63,
    0x6F, 0x6C, 0x73, 0x70, 0x61, 0x6E, 0x3D, 0x22, 0x32, 0x22, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65,
    0x3D, 0x22, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6F, 0x6C,
    0x6F, 0x72, 0x3A, 0x23, 0x39, 0x39, 0x62, 0x62, 0x62, 0x62, 0x3B, 0x22, 0x3E, 0x0D, 0x0A, 0x3C,
    0x68, 0x31, 0x3E, 0x20, 0x3C, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3E, 0xBB, 0xF9, 0xD3, 0xDA,
    0x43, 0x48, 0x33, 0x39, 0x35, 0x57, 0x45, 0x42, 0xB7, 0xFE, 0xCE, 0xF1, 0xC6, 0xF7, 0xD1, 0xDD,
    0xCA, 0xBE, 0xD2, 0xB3, 0xC3, 0xE6, 0x20, 0x20, 0x3C, 0x2F, 0x68, 0x31, 0x3E, 0x0D, 0x0A, 0x3C,
    0x2F, 0x74, 0x64, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x74, 0x72, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C,
    0x74, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x74, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x73, 0x70, 0x61, 0x6E,
    0x3D, 0x22, 0x32, 0x22, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3D, 0x22, 0x62, 0x61, 0x63, 0x6B,
    0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x67, 0x72, 0x61,
    0x79, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x35, 0x30, 0x70, 0x78, 0x3B, 0x22, 0x3E,
    0x0D, 0x0A, 0x3C, 0x68, 0x31, 0x3E, 0x3C, 0x6C, 0x65, 0x66, 0x74, 0x3E, 0x3C, 0x73, 0x6D, 0x61,
    0x6C, 0x6C, 0x3E, 0xCB, 0xB5, 0xC3, 0xF7, 0x3A, 0x31, 0xA1, 0xA2, 0xB1, 0xBE, 0xD2, 0xB3, 0xC3,
    0xE6, 0xD3, 0xC3, 0xD3, 0xDA, 0xD1, 0xDD, 0xCA, 0xBE, 0xBB, 0xF9, 0xD3, 0xDA, 0x43, 0x48, 0x33,
    0x39, 0x35, 0x57, 0x45, 0x42, 0xB7, 0xFE, 0xCE, 0xF1, 0xC6, 0xF7, 0xB9, 0xA4, 0xD7, 0xF7, 0xD4,
    0xAD, 0xC0, 0xED, 0x20, 0x3C, 0x62, 0x72, 0x3E, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x32, 0xA1, 0xA2, 0xCD,
    0xA8, 0xB9, 0xFD, 0xD2, 0xB3, 0xC3, 0xE6, 0xC9, 0xCF, 0xB5, 0xC4, 0xBF, 0xD8, 0xD6, 0xC6, 0xB0,
    0xB4, 0xC5, 0xA5, 0xA3, 0xAC, 0xC4, 0xFA, 0xBF, 0xC9, 0xD2, 0xD4, 0xCA, 0xB5, 0xCA, 0xB1, 0xD4,
    0xB6, 0xB3, 0xCC, 0x4C, 0x45, 0x44, 0xBF, 0xD8, 0xD6, 0xC6, 0x20, 0x3C, 0x62, 0x72, 0x3E, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62,
    0x73, 0x70, 0x3B, 0x33, 0xA1, 0xA2, 0xCD, 0xA8, 0xB9, 0xFD, 0xB9, 0xDB, 0xB2, 0xEC, 0xB4, 0xB0,
    0xBF, 0xDA, 0xBD, 0xF8, 0xD0, 0xD0, 0xD4, 0xB6, 0xB3, 0xCC, 0xCA, 0xFD, 0xBE, 0xDD, 0xBC, 0xE0,
    0xB2, 0xE2, 0x3C, 0x2F, 0x73, 0x6D, 0x61, 0x6C, 0x6C, 0x3E, 0x3C, 0x2F, 0x68, 0x31, 0x3E, 0x0D,
    0x0A, 0x3C, 0x2F, 0x74, 0x64, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x74, 0x72, 0x3E, 0x0D, 0x0A, 0x3C,
    0x74, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3D, 0x22, 0x74, 0x6F, 0x70, 0x22, 0x3E,
    0x0D, 0x0A, 0x3C, 0x74, 0x64, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3D, 0x22, 0x62, 0x61, 0x63,
    0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x66,
    0x66, 0x66, 0x66, 0x39, 0x39, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x36, 0x30, 0x30, 0x70,
    0x78, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x74, 0x6F, 0x70,
    0x3B, 0x22, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C,
    0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x73, 0x74, 0x72, 0x6F, 0x6E, 0x67, 0x3E, 0x3C, 0x66, 0x6F,
    0x6E, 0x74, 0x20, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x3D, 0x20, 0x31, 0x33, 0x20, 0x3E, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62,
    0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x3B, 0x20, 0x20, 0xBF, 0xD8, 0xD6, 0xC6, 0xB4, 0xB0, 0xBF, 0xDA, 0x3C, 0x2F, 0x66, 0x6F, 0x6E,
    0x74, 0x3E, 0x09, 0x3C, 0x2F, 0x73, 0x74, 0x72, 0x6F, 0x6E, 0x67, 0x3E, 0x0D, 0x0A, 0x3C, 0x62,
    0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62,
    0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x66,
    0x6F, 0x72, 0x6D, 0x20, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x22, 0x4C, 0x45, 0x44,
    0x43, 0x4F, 0x4E, 0x54, 0x52, 0x4F, 0x4C, 0x2E, 0x43, 0x47, 0x49, 0x22, 0x3E, 0x0D, 0x0A, 0x3C,
    0x73, 0x74, 0x72, 0x6F, 0x6E, 0x67, 0x3E, 0x3C, 0x66, 0x6F, 0x6E, 0x74, 0x20, 0x20, 0x73, 0x69,
    0x7A, 0x65, 0x20, 0x3D, 0x20, 0x35, 0x20, 0x3E, 0x0D, 0x0A, 0x09, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x0D, 0x0A, 0x09,
    0x4C, 0x45, 0x44, 0x31, 0x20, 0xD7, 0xB4, 0xCC, 0xAC, 0xA3, 0xBA, 0xC3, 0xF0, 0x20, 0x26, 0x6E,
    0x62, 0x73, 0x70, 0x20, 0x20, 0x3C, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75,
    0x65, 0x3D, 0x22, 0x31, 0x22, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x22, 0x6C, 0x65, 0x64, 0x31,
    0x22, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3D, 0x22, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x62, 0x6F, 0x78,
    0x22, 0x3E, 0xB4, 0xF2, 0xBF, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73,
    0x70, 0x20, 0x09, 0x3C, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D,
    0x22, 0x32, 0x22, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x22, 0x6C, 0x65, 0x64, 0x31, 0x22, 0x20,
    0x74, 0x79, 0x70, 0x65, 0x3D, 0x22, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x62, 0x6F, 0x78, 0x22, 0x3E,
    0xB9, 0xD8, 0xB1, 0xD5, 0x20, 0x0D, 0x0A, 0x20, 0x20, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72,
    0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73,
    0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x4C, 0x45, 0x44, 0x32, 0x20, 0xD7, 0xB4, 0xCC,
    0xAC, 0xA3, 0xBA, 0xC3, 0xF0, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x3C, 0x69, 0x6E,
    0x70, 0x75, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x22, 0x33, 0x22, 0x20, 0x6E, 0x61,
    0x6D, 0x65, 0x3D, 0x22, 0x6C, 0x65, 0x64, 0x32, 0x22, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3D, 0x22,
    0x63, 0x68, 0x65, 0x63, 0x6B, 0x62, 0x6F, 0x78, 0x22, 0x3E, 0xB4, 0xF2, 0xBF, 0xAA, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x09, 0x3C, 0x69, 0x6E, 0x70, 0x75,
    0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x22, 0x34, 0x22, 0x20, 0x6E, 0x61, 0x6D, 0x65,
    0x3D, 0x22, 0x6C, 0x65, 0x64, 0x32, 0x22, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3D, 0x22, 0x63, 0x68,
    0x65, 0x63, 0x6B, 0x62, 0x6F, 0x78, 0x22, 0x3E, 0xB9, 0xD8, 0xB1, 0xD5, 0x20, 0x0D, 0x0A, 0x0D,
    0x0A, 0x3C, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x3E, 0x09, 0x3C, 0x2F, 0x73, 0x74, 0x72, 0x6F, 0x6E,
    0x67, 0x3E, 0x0D, 0x0A, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A,
    0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E,
    0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73,
    0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20,
    0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E,
    0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20,
    0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62,
    0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x0D, 0x0A, 0x3C, 0x69, 0x6E, 0x70, 0x75, 0x74,
    0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x22, 0x53, 0x65, 0x6E, 0x64, 0x22, 0x20, 0x74, 0x79,
    0x70, 0x65, 0x3D, 0x22, 0x73, 0x75, 0x62, 0x6D, 0x69, 0x74, 0x22, 0x3E, 0x20, 0x3C, 0x2F, 0x66,
    0x6F, 0x72, 0x6D, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C, 0x68, 0x33, 0x3E,
    0x3C, 0x66, 0x6F, 0x6E, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x3D, 0x22, 0x2D, 0x31, 0x22, 0x3E,
    0x3C, 0x73, 0x70, 0x61, 0x6E, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3D, 0x22, 0x63, 0x6F, 0x6C,
    0x6F, 0x72, 0x3A, 0x20, 0x62, 0x6C, 0x61, 0x63, 0x6B, 0x3B, 0x22, 0x3E, 0x3C, 0x2F, 0x73, 0x70,
    0x61, 0x6E, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x3E, 0x3C, 0x2F, 0x68, 0x33,
    0x3E, 0x3C, 0x68, 0x33, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3D, 0x22, 0x66, 0x6F, 0x6E, 0x74,
    0x2D, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x20, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x3B,
    0x20, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79, 0x3A, 0x20, 0x56, 0x65,
    0x72, 0x64, 0x61, 0x6E, 0x61, 0x3B, 0x22, 0x3E, 0x3C, 0x66, 0x6F, 0x6E, 0x74, 0x20, 0x73, 0x69,
    0x7A, 0x65, 0x3D, 0x22, 0x2D, 0x31, 0x22, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F,
    0x66, 0x6F, 0x6E, 0x74, 0x3E, 0x3C, 0x2F, 0x68, 0x33, 0x3E, 0x0D, 0x0A, 0x3C, 0x62, 0x72, 0x3E,
    0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C, 0x73, 0x74, 0x72, 0x6F, 0x6E, 0x67, 0x3E,
    0x0D, 0x0A, 0x3C, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x22,
    0x43, 0x48, 0x33, 0x39, 0x35, 0x53, 0x45, 0x54, 0x49, 0x4E, 0x47, 0x2E, 0x43, 0x47, 0x49, 0x22,
    0x3E, 0x0D, 0x0A, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62,
    0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B,
    0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x49, 0x50, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x26, 0x6E, 0x62, 0x73,
    0x70, 0x20, 0x20, 0x3A, 0x3C, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D,
    0x49, 0x50, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3D, 0x74, 0x65, 0x78, 0x74, 0x20, 0x76, 0x61, 0x6C,
    0x75, 0x65, 0x3D, 0x20, 0x31, 0x39, 0x32, 0x2E, 0x31, 0x36, 0x38, 0x2E, 0x31, 0x31, 0x31, 0x2E,
    0x36, 0x34, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x26, 0x6E,
    0x62, 0x73, 0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20,
    0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3D, 0x22, 0x20, 0x63, 0x6F,
    0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x62, 0x6C, 0x61, 0x63, 0x6B, 0x22, 0x20, 0x3E, 0x3C, 0x62, 0x72,
    0x3E, 0x0D, 0x0A, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62,
    0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B,
    0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x50, 0x4F, 0x52, 0x54, 0x20, 0x3A, 0x3C, 0x69, 0x6E, 0x70, 0x75,
    0x74, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x50, 0x4F, 0x52, 0x54, 0x20, 0x74, 0x79, 0x70, 0x65,
    0x3D, 0x74, 0x65, 0x78, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x20, 0x38, 0x30, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x26, 0x6E, 0x62, 0x73,
    0x70, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3D, 0x22, 0x20,
    0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x62, 0x6C, 0x61, 0x63, 0x6B, 0x22, 0x20, 0x3E, 0x3C,
    0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20,
    0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E,
    0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73,
    0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B,
    0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E,
    0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26, 0x6E, 0x62, 0x73, 0x70,
    0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x3B, 0x26,
    0x6E, 0x62, 0x73, 0x70, 0x3B, 0x20, 0x26, 0x6E, 0x62, 0x73, 0x70, 0x20, 0x20, 0x3C, 0x69, 0x6E,
    0x70, 0x75, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3D, 0x22, 0x73, 0x75, 0x62, 0x6D, 0x69, 0x74,
    0x22, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x22, 0x43, 0x48, 0x41, 0x4E, 0x47, 0x45, 0x22,
    0x3E, 0x3C, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x73, 0x74, 0x72, 0x6F,
    0x6E, 0x67, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C, 0x2F, 0x74, 0x64, 0x3E, 0x0D, 0x0A, 0x3C, 0x74,
    0x64, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3D, 0x22, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F,
    0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x73, 0x69, 0x6C, 0x76, 0x65, 0x72,
    0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x36, 0x30, 0x30, 0x70, 0x78, 0x3B, 0x77, 0x69,
    0x64, 0x74, 0x68, 0x3A, 0x36, 0x30, 0x30, 0x70, 0x78, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x61,
    0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x74, 0x6F, 0x70, 0x3B, 0x22, 0x3E, 0x0D, 0x0A, 0x3C, 0x63, 0x65,
    0x6E, 0x74, 0x65, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C,
    0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x73, 0x74, 0x72, 0x6F, 0x6E, 0x67, 0x3E, 0x3C, 0x66, 0x6F,
    0x6E, 0x74, 0x20, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x3D, 0x20, 0x31, 0x33, 0x20, 0x3E, 0xBC,
    0xE0, 0xB2, 0xE2, 0xB4, 0xB0, 0xBF, 0xDA, 0x3C, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x3E, 0x09, 0x3C,
    0x2F, 0x73, 0x74, 0x72, 0x6F, 0x6E, 0x67, 0x3E, 0x0D, 0x0A, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62,
    0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62,
    0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A,
    0x3C, 0x73, 0x74, 0x72, 0x6F, 0x6E, 0x67, 0x3E, 0x3C, 0x66, 0x6F, 0x6E, 0x74, 0x20, 0x20, 0x73,
    0x69, 0x7A, 0x65, 0x20, 0x3D, 0x20, 0x36, 0x20, 0x3E, 0x0D, 0x0A, 0x20, 0x3C, 0x62, 0x72, 0x3E,
    0x0D, 0x0A, 0x20, 0x3C, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3D,
    0x22, 0x6D, 0x6F, 0x6E, 0x69, 0x74, 0x6F, 0x72, 0x2E, 0x43, 0x47, 0x49, 0x22, 0x3E, 0x0D, 0x0A,
    0x20, 0xCE, 0xC2, 0xB6, 0xC8, 0xA3, 0xBA, 0x32, 0x35, 0x20, 0x20, 0xA1, 0xE3, 0x0D, 0x0A, 0x20,
    0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x20, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x20, 0x26, 0x6E,
    0x62, 0x73, 0x70, 0x3B, 0xB5, 0xE7, 0xC1, 0xF7, 0xA3, 0xBA, 0x35, 0x30, 0x20, 0x20, 0x4D, 0x41,
    0x0D, 0x0A, 0x20, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x20, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A,
    0x20, 0xB5, 0xE7, 0xD1, 0xB9, 0xA3, 0xBA, 0x31, 0x32, 0x20, 0x20, 0x56, 0x0D, 0x0A, 0x20, 0x3C,
    0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x20, 0x3C, 0x62, 0x72, 0x3E, 0x0D, 0x0A, 0x20, 0x3C, 0x69, 0x6E,
    0x70, 0x75, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3D, 0x22, 0x73, 0x75, 0x62, 0x6D, 0x69, 0x74,
    0x22, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x22, 0x77, 0x61, 0x74, 0x63, 0x68, 0x22, 0x3E,
    0x0D, 0x0A, 0x3C, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x3E, 0x09, 0x3C, 0x2F, 0x73, 0x74, 0x72, 0x6F,
    0x6E, 0x67, 0x3E, 0x09, 0x0D, 0x0A, 0x3C, 0x2F, 0x74, 0x64, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C,
    0x2F, 0x74, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x74, 0x72, 0x3E, 0x0D, 0x0A, 0x3C, 0x74, 0x64, 0x20,
    0x63, 0x6F, 0x6C, 0x73, 0x70, 0x61, 0x6E, 0x3D, 0x22, 0x32, 0x22, 0x20, 0x73, 0x74, 0x79, 0x6C,
    0x65, 0x3D, 0x22, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6F,
    0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x39, 0x39, 0x62, 0x62, 0x62, 0x62, 0x3B, 0x74, 0x65, 0x78, 0x74,
    0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x22, 0x3E,
    0x0D, 0x0A, 0x43, 0x6F, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x3C, 0x41, 0x20, 0x68,
    0x72, 0x65, 0x66, 0x20, 0x3D, 0x20, 0x22, 0x77, 0x77, 0x77, 0x2E, 0x77, 0x63, 0x68, 0x2E, 0x63,
    0x6E, 0x22, 0x3E, 0x20, 0x77, 0x77, 0x77, 0x2E, 0x77, 0x63, 0x68, 0x2E, 0x63, 0x6E, 0x3C, 0x2F,
    0x41, 0x3E, 0x3C, 0x2F, 0x74, 0x64, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x74, 0x72, 0x3E, 0x0D, 0x0A,
    0x3C, 0x2F, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3E, 0x0D, 0x0A, 0x0D, 0x0A, 0x3C, 0x2F, 0x62, 0x6F,
    0x64, 0x79, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x68, 0x74, 0x6D, 0x6C, 0x3E};

/*********************************************************************************
 * Function Name  : MakeHttpResponse
 * Description    : Generates the response message
 * Input          : buf   -   response buf
                    type  -   URI type
 * Output         : None
 * Return         : None
 *********************************************************************************/
void MakeHttpResponse(unsigned char *buf, char type)
{
    char *head = 0;
    char tmp[10];
    UINT16 len;
    if (type == PTYPE_HTML)
        head = RES_HTMLHEAD_OK;
    else if (type == PTYPE_GIF)
        head = RES_GIFHEAD_OK;
    else if (type == PTYPE_TEXT)
        head = RES_TEXTHEAD_OK;
    else if (type == PTYPE_JPEG)
        head = RES_JPEGHEAD_OK;
    else if (type == PTYPE_FLASH)
        head = RES_FLASHHEAD_OK;
    else if (type == PTYPE_MPEG)
        head = RES_MPEGHEAD_OK;
    else if (type == PTYPE_PDF)
        head = RES_PDFHEAD_OK;
    else if (type == PTYPE_CGI)
        head = RETURN_CGI_PAGE;
    len = sizeof(HtmlBuffer);
    sprintf(tmp, "%ld", len);
    strcpy((char *)buf, head);
    strcat((char *)buf, tmp);
    strcat((char *)buf, "\r\n\r\n");
}

/*********************************************************************************
 * Function Name  : ParseUriType
 * Description    : Parses the URI type
 * Input          : type   -   URI type
                    buf    -   URI buf
 * Output         : None
 * Return         : None
 *********************************************************************************/
void ParseUriType(UINT8 *type, char *buf)
{
    if (strstr(buf, ".htm"))
        *type = PTYPE_HTML;
    else if (strstr(buf, ".gif"))
        *type = PTYPE_GIF;
    else if (strstr(buf, ".text") || strstr(buf, ".txt"))
        *type = PTYPE_TEXT;
    else if (strstr(buf, ".jpeg") || strstr(buf, ".jpg"))
        *type = PTYPE_JPEG;
    else if (strstr(buf, ".swf"))
        *type = PTYPE_FLASH;
    else if (strstr(buf, ".mpeg") || strstr(buf, ".mpg"))
        *type = PTYPE_MPEG;
    else if (strstr(buf, ".pdf"))
        *type = PTYPE_PDF;
    else if (strstr(buf, ".cgi") || strstr(buf, ".CGI"))
        *type = PTYPE_CGI;
    else if (strstr(buf, ".js") || strstr(buf, ".JS"))
        *type = PTYPE_TEXT;
    else if (strstr(buf, ".xml") || strstr(buf, ".XML"))
        *type = PTYPE_HTML;
    else
        *type = PTYPE_ERR;
}

/*********************************************************************************
 * Function Name  : ParseHttpRequest
 * Description    : Parses the HTTP request
 * Input          : request   - request structure pointer
                    buf       - request buffer pointer
 * Output         : None
 * Return         : None
 *********************************************************************************/
void ParseHttpRequest(st_http_request *request, UINT8 *buf)
{
    char *nexttok;
    nexttok = strtok((char *)buf, " ");
    if (!nexttok)
    {
        request->METHOD = METHOD_ERR;
        return;
    }
    if (!strcmp(nexttok, "GET") || !strcmp(nexttok, "get"))
    {
        request->METHOD = METHOD_GET;
        nexttok = strtok(NULL, " ");
        printf("METHOD = GET!\n");
    }
    else if (!strcmp(nexttok, "HEAD") || !strcmp(nexttok, "head"))
    {
        request->METHOD = METHOD_HEAD;
        nexttok = strtok(NULL, " ");
        printf("METHOD = HEAD!\n");
    }
    else if (!strcmp(nexttok, "POST") || !strcmp(nexttok, "post"))
    {
        nexttok = strtok(NULL, "\0");
        request->METHOD = METHOD_POST;
        printf("METHOD = POST!\n");
    }
    else
    {
        request->METHOD = METHOD_ERR;
    }

    if (!nexttok)
    {
        request->METHOD = METHOD_ERR;
        return;
    }
    strcpy((char *)request->URI, nexttok);
}

/*********************************************************************************
 * Function Name  : DataLocate
 * Description    : Finds the position of the specified character
 * Input          : buf   - Buffer pointer
                    name  - Character to find
 * Output         : None
 * Return         : None
 *********************************************************************************/
char *DataLocate(char *buf, char *name)
{
    char *p;
    p = strstr(buf, name);
    if (p == NULL)
        return NULL;
    p += strlen(name);
    return p;
}

/*********************************************************************************
 * Function Name  : GetUriName
 * Description    : Gets the URI
 * Input          : URI
 * Output         : None
 * Return         : URI name
 *********************************************************************************/
unsigned char *GetUriName(char *uri)
{
    UINT8 *uri_name;
    if (!uri)
        return 0;
    memset(tempURI, 0, MAX_URI_SIZE);
    strcpy((char *)tempURI, uri);
    uri_name = (UINT8 *)strtok(tempURI, " ?");
    if (strcmp((char *)uri_name, "/"))
        uri_name++;
    return uri_name;
}

/* "LED1 状态：" string in GBK encoding */
char led1_status_str[] = {0x4C, 0x45, 0x44, 0x31, 0x20, 0xD7, 0xB4, 0xCC, 0xAC, 0xA3, 0xBA, 0x00};
/* "LED2 状态：" string in GBK encoding */
char led2_status_str[] = {0x4C, 0x45, 0x44, 0x32, 0x20, 0xD7, 0xB4, 0xCC, 0xAC, 0xA3, 0xBA, 0x00};
/*********************************************************************************
 * Function Name  : LedControl
 * Description    : LED control program
 * Input          : Buffer pointer
 * Output         : None
 * Return         : None
 *********************************************************************************/
void LedControl(UINT8 *buf)
{
    ptemp = strstr((char *)buf, "LEDCONTROL"); /* Search the receive buffer (browser request information) to check if there's an LED control request */
    if (ptemp != NULL)
    {
        ptemp = DataLocate((char *)buf, "led1=");
        if (ptemp != NULL)
        {
            if (*ptemp == '1') /* Check the value of led1. If it's 1, the LED is ON; if it's 2, the LED is OFF. This value is related to the settings in the HTML page */
            {
                printf("LED1-ON\n");
                GPIO_ResetBits(GPIOA, GPIO_Pin_11);
                ptemp = DataLocate((char *)HtmlBuffer, led1_status_str);
                printf("%x\n", *ptemp);
                *ptemp++ = 0xc1;
                *ptemp = 0xc1;
            }
            else
            {
                printf("LED1-OFF\n");
                GPIO_SetBits(GPIOA, GPIO_Pin_11);
                ptemp = DataLocate((char *)HtmlBuffer, led1_status_str);
                *ptemp++ = 0xc3;
                *ptemp = 0xf0;
            }
        }
        ptemp = strstr((char *)buf, "led2="); /* Check the value of led2. If it's 3, the LED is ON; if it's 4, the LED is OFF. This value is related to the settings in the HTML page */
        if (ptemp != NULL)
        {
            ptemp += strlen("led2 ");
            if (*ptemp == '3')
            {
                printf("LED2-ON\n");
                GPIO_ResetBits(GPIOA, GPIO_Pin_12);
                ptemp = DataLocate((char *)HtmlBuffer, led2_status_str);
                *ptemp++ = 0xc1;
                *ptemp = 0xc1;
            }
            else
            {
                printf("LED2-OFF\n");
                GPIO_SetBits(GPIOA, GPIO_Pin_12);
                ptemp = DataLocate((char *)HtmlBuffer, led2_status_str);
                *ptemp++ = 0xc3;
                *ptemp = 0xf0;
            }
        }
    }
}

/*********************************************************************************
 * Function Name  : IpSeting
 * Description    : IP setting
 * Input          : buf1  - Buffer pointer
                    buf2  - Buffer2 pointer
 * Output         : None
 * Return         : None
 *********************************************************************************/
void IpSeting(UINT8 *buf1, UINT8 *buf2)
{
    char *p = 0;
    UINT8 i;
    UINT8 tbuf[128];
    strcpy((char *)tbuf, (char *)buf1);
    p = DataLocate((char *)tbuf, "IP"); /* Move the pointer to the IP */
    p++;
    for (i = 0; i < 3; i++)
    {
        p = strtok((char *)p, ".");
        *buf2++ = atoi((char *)p);
        p = NULL;
    }
    p = strtok(p, "&");
    *buf2++ = atoi((char *)p);
}

/*********************************************************************************
 * Function Name  : IpRefrsh
 * Description    : Update IP information to the web page
 * Input          : buf   - Buffer pointer
                    buf2  - Buffer2 pointer
 * Output         : None
 * Return         : None
 *********************************************************************************/
void IpRefrsh(UINT8 *buf, UINT8 *buf2)
{
    UINT8 s[20], i;
    char *p;
    sprintf((char *)s, "%d.%d.%d.%d ", (UINT16)buf2[0], (UINT16)buf2[1], (UINT16)buf2[2], (UINT16)buf2[3]); /* Format the new IP into the set buffer */
    p = DataLocate((char *)buf, "IP type=text value");
    p++;
    for (i = 0; i < strlen((char *)s); i++) /* Update the formatted IP content in the set buffer into the web page information */
    {
        *p++ = s[i];
    }
}

/*********************************************************************************
 * Function Name  : PortSeting
 * Description    : Port setting
 * Input          : Buffer pointer
 * Output         : None
 * Return         : port
 *********************************************************************************/
UINT16 PortSeting(UINT8 *buf)
{
    char *p;
    UINT8 s[10], i;
    UINT16 port = 0;
    p = DataLocate((char *)buf, "PORT"); /* Extract port information from the request */
    if (p != NULL)
    {
        p++;
        memset(s, 0, 10);
        i = 0;
        while (*p != 0)
        {
            s[i++] = *p++;
        }
        port = atoi((char *)s);
    }
    return port;
}

/*********************************************************************************
 * Function Name  : PortRefresh
 * Description    : Update port information to the web page
 * Input          : buf   - Buffer pointer
                    port  - Port value
 * Output         : None
 * Return         : None
 *********************************************************************************/
void PortRefresh(UINT8 *buf, UINT16 port)
{
    UINT8 s[10], i;
    char *p;
    sprintf((char *)s, "%d", (UINT16)port);
    p = DataLocate((char *)buf, "PORT type=text value=");
    for (i = 0; i < strlen((char *)s); i++)
    {
        *p++ = s[i];
    }
    for (i = 0; i < 3; i++)
    {
        *p++ = 0x20;
    }
}

/* "温度" string in GBK encoding */
char Temp_status_str[] = {0xCE, 0xC2, 0xB6, 0xC8, 0x00};
/*********************************************************************************
 * Function Name  : TempratureRefresh
 * Description    : Update temperature information to the web page
 * Input          : buf   - Buffer pointer
                    temp  - Temperature value
 * Output         : None
 * Return         : None
 *********************************************************************************/
void TempratureRefresh(UINT8 *buf, UINT8 temp)
{
    UINT8 s[3], i;
    char *p;
    sprintf((char *)s, "%d", temp); /* Set the temperature information and refresh it to the WEB page */
    p = DataLocate((char *)buf, Temp_status_str);
    p++;
    p++;
    for (i = 0; i < 2; i++)
    {
        *p++ = s[i];
    }
}

/* "电流" string in GBK encoding */
char curr_status_str[] = {0xB5, 0xE7, 0xC1, 0xF7, 0x00};
/**********************************************************************************
 * Function Name  : CurrentRefresh
 * Description    : Update current information to the web page
 * Input          : buf   - Buffer pointer
                    curr  - Current value
 * Output         : None
 * Return         : None
 *********************************************************************************/
void CurrentRefresh(UINT8 *buf, UINT8 curr)
{
    UINT8 s[3], i;
    char *p;
    sprintf((char *)s, "%d", curr); /* Set the current information and refresh it to the WEB page */
    p = DataLocate((char *)buf, curr_status_str);
    p++;
    p++;
    for (i = 0; i < 2; i++)
    {
        *p++ = s[i];
    }
}

/* "电压" string in GBK encoding */
char valtage_status_str[] = {0xB5, 0xE7, 0xC1, 0xF7, 0x00};
/**********************************************************************************
 * Function Name  : VoltageRefresh
 * Description    : Update Voltage information to the web page
 * Input          : buf   - Buffer pointer
                    volt  - Voltage value
 * Output         : None
 * Return         : None
 *********************************************************************************/
void VoltageRefresh(UINT8 *buf, UINT8 volt)
{
    UINT8 s[3], i;
    char *p;
    sprintf((char *)s, "%d", volt); /* Set the voltage information and refresh it to the WEB page */
    p = DataLocate((char *)buf, valtage_status_str);
    p++;
    p++;
    for (i = 0; i < 2; i++)
    {
        *p++ = s[i];
    }
}

/**********************************************************************************
 * Function Name  : ADCData
 * Description    : Use random numbers to simulate ADC data
 * Input          : Buffer pointer
 * Output         : None
 * Return         : None
 *********************************************************************************/
void ADCData(UINT8 *buf) /* Random number generation, simulate ADC results */
{
    *buf++ = 10 + (UINT16)rand() % 30;
    *buf++ = 10 + (UINT16)rand() % 50;
    *buf = 10 + (UINT16)rand() % 10;
}

/**********************************************************************************
 * Function Name  : WebServer
 * Description    : Main program of the web service
 * Input          : None
 * Output         : None
 * Return         : None
 *********************************************************************************/
void WebServer(void)
{
    switch (WebServer_handle_step)
    {
    case WEB_SERVER_STEP_IDLE:
    {
        if (WebServer_flag & RECVDATA)
        {
            WebServer_flag &= ~RECVDATA;
            ParseHttpRequest(http_request, WebServer_RecvBuffer);
            switch (http_request->METHOD)
            {
            case METHOD_ERR:
                break;
            case METHOD_HEAD:
            case METHOD_POST:
            case METHOD_GET:
                name = (char *)GetUriName((char *)http_request->URI);
                printf("name:%s\r\n", name);
                if (!strcmp(name, "/"))
                {
                    http_request->TYPE = PTYPE_HTML;
                }
                else
                {
                    ParseUriType(&http_request->TYPE, name);
                }
                WebServer_handle_step = WEB_SERVER_STEP_PROCESSING;
            }
        }
    }
    break;
    case WEB_SERVER_STEP_PROCESSING:
    {
        if (http_request->TYPE == PTYPE_CGI)
        {
            LedControl(http_request->URI);                             /* LED control part */
            ptr1 = strstr((char *)(http_request->URI), "CH395SETING"); /* Check if there is a CH395 setting request in the received buffer (browser request info) */
            if (ptr1 != NULL)
            {
                ptr1 = strstr((char *)(http_request->URI), "IP"); /* Extract IP information from browser request */
                if (ptr1 != NULL)
                {
                    printf("******IP****************************************\n");
                    IpSeting((http_request->URI), ip);
                    printf("New IP address = %d.%d.%d.%d\n", (UINT16)ip[0], (UINT16)ip[1], (UINT16)ip[2], (UINT16)ip[3]);
                    i = memcmp(lastip, ip, 4); /* Compare with the last extracted IP to check if it has changed, if so execute the IP setting part */
                    if (i)
                    {                              /* IP changed */
                        WebServer_flag |= IPCHANGE; /* IP changed, flag bit 0 set to 1 */
                        printf("ip change\n");
                        memcpy(CH395IPAddr, ip, 4); /* Update the IP information of CH395 */
                        memcpy(lastip, ip, 4);      /* Assign new IP to the previous one for future comparison */
                        IpRefrsh(HtmlBuffer, ip);
                    }
                }

                ptr1 = strstr((char *)(http_request->URI), "PORT"); /* Extract Port information from request */
                if (ptr1 != NULL)
                {
                    printf("******PORT****************************************\n");
                    port = PortSeting(http_request->URI);
                    printf("New Port = %2d\n", (UINT16)port);
                    if (port != lastport) /* Compare with the last extracted Port to check if it has changed */
                    {
                        WebServer_flag |= PORTCHANGE; /* Port changed, flag bit 1 set to 1 */
                        Socket0SourPort = port;
                        lastport = port;
                        printf("port change\n");
                        PortRefresh(HtmlBuffer, port);
                    }
                }
            }

            ptr1 = strstr((char *)(http_request->URI), "monitor"); /* Check if there is a request to view monitoring information */
            if (ptr1 != NULL)
            {
                ADCData(ADC);
                TempratureRefresh(HtmlBuffer, ADC[0]);
                CurrentRefresh(HtmlBuffer, ADC[1]);
                VoltageRefresh(HtmlBuffer, ADC[2]);
            }
        }
        WebServer_handle_step = WEB_SERVER_STEP_SEND_HEADER;
    }
    break;
    case WEB_SERVER_STEP_SEND_HEADER:
    {
        if ((WebServer_flag & SENDDATA) == 0)
        {
            WebServer_flag |= SENDDATA;

            MakeHttpResponse(httpweb, http_request->TYPE);
            WebServer_SendLen = strlen((char *)httpweb);
            WebServer_Send_point = httpweb;
            WebServer_handle_step = WEB_SERVER_STEP_SEND_DATA;
        }
    }
    break;
    case WEB_SERVER_STEP_SEND_DATA:
    {
        if ((WebServer_flag & SENDDATA) == 0)
        {
            WebServer_flag |= SENDDATA;
            WebServer_SendLen = sizeof(HtmlBuffer);
            WebServer_Send_point = HtmlBuffer;
            WebServer_handle_step = WEB_SERVER_STEP_SEND_SUC;
        }
    }
    break;
    case WEB_SERVER_STEP_SEND_SUC:
    {
        if ((WebServer_flag & SENDDATA) == 0)
        {
			Delay_Ms(10);
            CH395CMDTCPDisconnect(0);
            WebServer_handle_step = WEB_SERVER_STEP_IDLE;
        }
    }

    break;
    default:
        break;
    }
}
